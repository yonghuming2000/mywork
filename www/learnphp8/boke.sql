/*
Navicat MySQL Data Transfer

Source Server         : localhost
Source Server Version : 50728
Source Host           : localhost:3306
Source Database       : boke

Target Server Type    : MYSQL
Target Server Version : 50728
File Encoding         : 65001

Date: 2021-03-19 09:52:34
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article` (
  `title` varchar(300) CHARACTER SET utf8 DEFAULT NULL COMMENT '标题',
  `img` varchar(300) CHARACTER SET utf8 DEFAULT NULL COMMENT '图片',
  `content` text CHARACTER SET utf8 COMMENT '内容',
  `date` date DEFAULT NULL COMMENT '时间',
  `class` varchar(50) CHARACTER SET utf8 DEFAULT NULL COMMENT '类型'
) ENGINE=InnoDB DEFAULT CHARSET=sjis;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES ('php中文网原创视频：《天龙八部》公益php培训系列课程汇总！', 'https://img.php.cn/upload/course/000/000/001/5d242759adb88970.jpg', 'PHP中文网因专业的讲师水平和高效的视频质量，推出的各种视频课程系列一直以来都深受大家喜爱。特别是《天龙八部》系列、《独孤九贱》系列、《玉女心经》系列的原创课程在行业内更是具有强大的影响力，好评不断！为了让大家能更快速方便的寻找到相关教程资源，我们在这篇文章中特意将《天龙八部》系列课程整理出来供大家有针对性得学习！', '2021-02-18', 'PHP');
INSERT INTO `article` VALUES ('php中文网《玉女心经》公益PHP WEB培训系列课程汇总', 'https://img.php.cn/upload/course/000/126/153/5aa23f0ded921649.jpg', 'php中文网近期推出的《独孤九贱》系列、《天龙八部》系列、《玉女心经》原创视频课程，好评如潮！由于《玉女心经》系列课程没有做成专题，所以大家找起来有点费劲，为了更好的服务广大php中文网粉丝们，特把课程整理汇总给大家！', '2021-02-11', 'PHP');
INSERT INTO `article` VALUES ('html5中submit是按钮么', null, 'html5中submit是按钮，它是button的一个特例，它把提交这个动作自动集成了。submit会自动将表单的数据提交，使用submit时需要验证要加return', '2021-02-10', '前端');
INSERT INTO `article` VALUES ('css如何去除下划线', null, 'css去除下划线的方法：首先创建一个HTML示例文件；然后在body中定义一个a标签；最后通过css属性为“a{text-decoration:none}”去除下划线即可。', '2021-02-01', '前端');
INSERT INTO `article` VALUES ('linux如何查看进程', 'https://img.php.cn/upload/article/202102/24/2021022409272725770.jpg', 'windows defender是windows系统自带的一款杀毒软件，对于很多人来说，这款软件不仅没有起到保护电脑的作用，还增加了很多不必要的麻烦。比如我们安装了一些破解版软件，windows defender就会杀这些破解软件，很让人讨厌。', '2021-02-01', '服务器');
INSERT INTO `article` VALUES ('Ubuntu20.04/18.04下安装或更新至PHP8', 'https://img.php.cn/upload/article/000/000/020/2c02ff679ec7afab974a691aac09d535-0.png', '本指南让你了解如何安装最新的 php 版本 8，并在你的任何 VPS、云服务器、专用主机上的 Ubuntu 20.0 或 18.04 系统中升级到最新版本，并将其配置为 Apache 和 Nginx。', '2021-02-01', 'PHP');
INSERT INTO `article` VALUES ('PHP 8新特性之JIT对PHP应用性能的影响', null, '即将发布的 PHP 8 最受大家关注的新特性就是引入了对 JIT 的支持，我已经简单介绍了 JIT 是什么，以及与 Opcache 的区别', '2021-02-01', 'PHP');
INSERT INTO `article` VALUES ('详解PHP7中的zval结构和引用计数机制', 'https://img.php.cn/upload/article/000/000/024/6053286f637d2966.jpg', '最近在查阅 PHP7 垃圾回收的资料的时候，网上的一些代码示例在本地环境下运行时出现了不同的结果，使我一度非常迷惑。 仔细一想不难发现问题所在：这些文章大多是 PHP5.x 时代的，而 PHP7 发布后，采用了新的 zval 结构，相关的资料也比较贫瘠，所以我结合一些资料做了一个总结，主要侧重于解释新 zval 容器中的引用计数机制，如有谬误，还望不吝指教。\r\n\r\nPHP7 中新的 zval 结构\r\n明人不说暗话，先看代码！\r\n\r\n1\r\n\r\n2\r\n\r\n3\r\n\r\n4\r\n\r\n5\r\n\r\n6\r\n\r\n7\r\n\r\n8\r\n\r\n9\r\n\r\n10\r\n\r\n11\r\n\r\n12\r\n\r\n13\r\n\r\n14\r\n\r\n15\r\n\r\n16\r\n\r\n17\r\n\r\n18\r\n\r\n19\r\n\r\n20\r\n\r\n21\r\n\r\n22\r\n\r\n23\r\n\r\n24\r\n\r\n25\r\n\r\n26\r\n\r\n27\r\n\r\n28\r\n\r\n29\r\n\r\n30\r\n\r\n31\r\n\r\n32\r\n\r\n33\r\n\r\n34\r\n\r\n35\r\n\r\n36\r\n\r\n37\r\n\r\n38\r\n\r\n39\r\n\r\n40\r\n\r\n41\r\n\r\nstruct _zval_struct {\r\n\r\n    union {\r\n\r\n        zend_long         lval;             /* long value */\r\n\r\n        double            dval;             /* double value */\r\n\r\n        zend_refcounted  *counted;\r\n\r\n        zend_string      *str;\r\n\r\n        zend_array       *arr;\r\n\r\n        zend_object      *obj;\r\n\r\n        zend_resource    *res;\r\n\r\n        zend_reference   *ref;\r\n\r\n        zend_ast_ref     *ast;\r\n\r\n        zval             *zv;\r\n\r\n        void             *ptr;\r\n\r\n        zend_class_entry *ce;\r\n\r\n        zend_function    *func;\r\n\r\n        struct {\r\n\r\n            uint32_t w1;\r\n\r\n            uint32_t w2;\r\n\r\n        } ww;\r\n\r\n    } value;\r\n\r\n    union {\r\n\r\n        struct {\r\n\r\n            ZEND_ENDIAN_LOHI_4(\r\n\r\n                zend_uchar    type,         /* active type */\r\n\r\n                zend_uchar    type_flags,\r\n\r\n                zend_uchar    const_flags,\r\n\r\n                zend_uchar    reserved)     /* call info for EX(This) */\r\n\r\n        } v;\r\n\r\n        uint32_t type_info;\r\n\r\n    } u1;\r\n\r\n    union {\r\n\r\n        uint32_t     var_flags;\r\n\r\n        uint32_t     next;                 /* hash collision chain */\r\n\r\n        uint32_t     cache_slot;           /* literal cache slot */\r\n\r\n        uint32_t     lineno;               /* line number (for ast nodes) */\r\n\r\n        uint32_t     num_args;             /* arguments number for EX(This) */\r\n\r\n        uint32_t     fe_pos;               /* foreach position */\r\n\r\n        uint32_t     fe_iter_idx;          /* foreach iterator index */\r\n\r\n    } u2;\r\n\r\n};\r\n\r\n复制代码\r\n\r\n对于该结构的详细描述可以参考文末鸟哥的文章，写的非常详细，我就不关公面前耍大刀了，这里我只提出几个比较关键的点：\r\n\r\nPHP7 中的变量分为变量名和变量值两部分，分别对应 zval_struct 和在其中声明的 value\r\n\r\nzval_struct.value 中的 zend_long 、double 都是简单数据类型，能够直接储存具体的值，而其他复杂数据类型储存一个指向其他数据结构的指针\r\n\r\nPHP7 中，引用计数器储存在 value 中而不是 zval_struct\r\n\r\nNULL、布尔型都属于没有值的数据类型（其中布尔型通过 IS_FALSE 和 IS_TRUE 两个常量来标记），自然也就没有引用计数\r\n\r\n引用（REFERENCE）变为了一种数据结构而不再只是一个标记位了，它的结构如下：\r\n\r\n1\r\n\r\n2\r\n\r\n3\r\n\r\n4\r\n\r\nstruct _zend_reference {\r\n\r\n    zend_refcounted_h gc;\r\n\r\n    zval              val;\r\n\r\n}\r\n\r\nzend_reference 作为 zval_struct 中包含的一种 value 类型，也拥有自己的 val 值，这个值是指向一个 zval_struct.value 的。他们都拥有自己的引用计数器。\r\n\r\n引用计数器用来记录当前有多少 zval 指向同一个 zend_value。\r\n针对第六点，请看如下代码：\r\n\r\n1\r\n\r\n2\r\n\r\n3\r\n\r\n$a = \'foo\';\r\n\r\n$b = &$a;\r\n\r\n$c = $a;\r\n\r\n此时的数据结构是这样的：\r\n\r\n$a 与 $b 各拥有一个 zval_struct 容器，并且其中的 value 都指向同一个 zend_reference 结构，zend_reference 内嵌一个 val 结构， 指向同一个 zend_string，字符串的内容就储存在其中。\r\n\r\n而 $c 也拥有一个 zval_struct，而它的 value 在初始化的时候可以直接指向上面提到的 zend_string ，这样在拷贝时就不会产生复制。\r\n\r\n下面我们就聊一聊在这种全新的 zval 结构中，会出现的种种现象，和这些现象背后的原因。\r\n\r\n问题\r\n一. 为什么某些变量的引用计数器的初始值为 0\r\n现象\r\n1\r\n\r\n2\r\n\r\n3\r\n\r\n4\r\n\r\n5\r\n\r\n6\r\n\r\n7\r\n\r\n8\r\n\r\n9\r\n\r\n10\r\n\r\n11\r\n\r\n12\r\n\r\n13\r\n\r\n14\r\n\r\n15\r\n\r\n16\r\n\r\n17\r\n\r\n18\r\n\r\n$var_int = 233;\r\n\r\n$var_float = 233.3;\r\n\r\n$var_str = \'233\';\r\n\r\n \r\n\r\nxdebug_debug_zval(\'var_int\');\r\n\r\nxdebug_debug_zval(\'var_float\');\r\n\r\nxdebug_debug_zval(\'var_str\');\r\n\r\n \r\n\r\n/** 输出 **\r\n\r\nvar_int:\r\n\r\n(refcount=0, is_ref=0)int 233\r\n\r\n \r\n\r\nvar_float:\r\n\r\n(refcount=0, is_ref=0)float 233.3\r\n\r\n \r\n\r\nvar_str:\r\n\r\n(refcount=0, is_ref=0)string \'233\' (length=3)\r\n\r\n**********/\r\n\r\n原因\r\n在 PHP7 中，为一个变量赋值的时候，包含了两部分操作：\r\n\r\n1、为符号量（即变量名）申请一个 zval_struct 结构\r\n\r\n2、将变量的值储存到 zval_struct.value 中 对于 zval 在 value 字段中能保存下的值，就不会在对他们进行引用计数，而是在拷贝的时候直接赋值，这部分类型有：\r\n\r\nIS_LONG\r\nIS_DOUBLE\r\n即我们在 PHP 中的整形与浮点型。\r\n\r\n那么 var_str 的 refcount 为什么也是 0 呢？\r\n这就牵扯到 PHP 中字符串的两种类型：\r\n\r\n1、interned string 内部字符串（函数名、类名、变量名、静态字符串）：\r\n\r\n1\r\n\r\n$str = \'233\';    // 静态字符串\r\n\r\n2、普通字符串：\r\n\r\n1\r\n\r\n$str = \'233\' . time();\r\n\r\n对于内部字符串而言，字符串的内容是唯一不变的，相当于 C 语言中定义在静态变量区的字符串，他们的生存周期存在于整个请求期间，request 完成后会统一销毁释放，自然也就无需通过引用计数进行内存管理。\r\n\r\n二. 为什么在对整形、浮点型和静态字符串型变量进行引用赋值时，计数器的值会直接变为2\r\n现象\r\n1\r\n\r\n2\r\n\r\n3\r\n\r\n4\r\n\r\n5\r\n\r\n6\r\n\r\n7\r\n\r\n8\r\n\r\n$var_int_1 = 233;\r\n\r\n$var_int_2 = &var_int;\r\n\r\nxdebug_debug_zval(\'var_int_1\');\r\n\r\n \r\n\r\n/** 输出 **\r\n\r\nvar_int:\r\n\r\n(refcount=2, is_ref=1)int 233\r\n\r\n**********/\r\n\r\n原因\r\n回忆一下我们开头讲的 zval_struct 中 value 的数据结构，当为一个变量赋整形、浮点型或静态字符串类型的值时，value 的数据类型为 zend_long 、 double 或 zend_string，这时值是可以直接储存在 value 中的。而按值拷贝时，会开辟一个新的 zval_struct 以同样的方式将值储存到相同数据类型的 value 中，所以 refcount 的值一直都会为 0。\r\n\r\n但是当使用 & 操作符进行引用拷贝时，情况就不一样了：\r\n\r\nPHP 为 & 操作符操作的变量申请一个 zend_reference 结构\r\n\r\n将 zend_reference.value 指向原来的 zval_struct.value\r\n\r\nzval_struct.value 的数据类型会被修改为 zend_refrence\r\n\r\n将 zval_struct.value 指向刚刚申请并初始化后的 zend_reference\r\n\r\n为新变量申请 zval_struct 结构，将他的 value 指向刚刚创建的 zend_reference\r\n\r\n此时：$var\\_int\\_1 和 $var_int_2 都拥有一个 zval_struct 结构体，并且他们的 zval_struct.value 都指向了同一个 zend_reference 结构，所以该结构的引用计数器的值为 2。\r\n\r\n题外话：zend_reference 又指向了一个整形或浮点型的 value，如果指向的 value 类型是 zend_string，那么该 value 引用计数器的值为 1。而 xdebug 出来的 refcount 显示的是 zend_reference 的计数器值（即 2）\r\n\r\n三. 为什么初始数组的引用计数器的值为 2\r\n现象\r\n1\r\n\r\n2\r\n\r\n3\r\n\r\n4\r\n\r\n5\r\n\r\n6\r\n\r\n7\r\n\r\n8\r\n\r\n9\r\n\r\n10\r\n\r\n11\r\n\r\n$var_empty_arr = [1, 2, \'3\'];\r\n\r\nxdebug_debug_zval(\'var_empty_arr\');\r\n\r\n \r\n\r\n/** 输出 **\r\n\r\nvar_arr:\r\n\r\n(refcount=2, is_ref=0)\r\n\r\narray (size=3)\r\n\r\n  0 => (refcount=0, is_ref=0)int 1\r\n\r\n  1 => (refcount=0, is_ref=0)int 2\r\n\r\n  2 => (refcount=1, is_ref=0)string \'3\' (length=1)\r\n\r\n**********/\r\n\r\n原因\r\n这牵扯到 PHP7 中的另一个概念，叫做 immutable array（不可变数组）。\r\n\r\nFor arrays the not-refcounted variant is called an \"immutable array\". If you use opcache, then constant array literals in your code will be converted into immutable arrays. Once again, these live in shared memory and as such must not use refcounting. Immutable arrays have a dummy refcount of 2, as it allows us to optimize certain separation paths.\r\n不可变数组是 opcache 扩展优化出的一种数组类型，简单的说，所有多次编译结果恒定不变的数组，都会被优化为不可变数组，下面是一个反例：\r\n\r\n1\r\n\r\n$array = [1, 2, time()];\r\n\r\nPHP 在编译阶段无法得知 time() 函数的返回值，所以此处的 $array 是可变数组。\r\n\r\n不可变数组和我们上面讲到的内部字符串一样，都是不使用引用计数的，但是不同点是，内部字符串的计数值恒为 0，而不可变数组会使用一个伪计数值 2。\r\n\r\n总结\r\n简单数据类型\r\n\r\n整形（不使用引用计数）\r\n浮点型（不使用引用计数）\r\n布尔型（不使用引用计数）\r\nNULL（不使用引用计数）\r\n复杂数据类型\r\n\r\n字符串\r\n\r\n普通字符串（使用引用计数，初始值为 1）\r\n内部字符串（不使用引用计数，引用计数值恒为 0）\r\n数组\r\n\r\n普通数组（使用引用计数，初始值为 1）\r\n不可变数组（不使用引用计数，使用伪计数值 2）\r\n对象（使用引用计数，初始值为 1）\r\n更多编程相关知识，请访问：编程视频！！\r\n\r\n以上就是详解PHP7中的zval结构和引用计数机制的详细内容，更多请关注php中文网其它相关文章！', '2021-01-01', 'PHP');
INSERT INTO `article` VALUES ('php登录失败怎么处理', 'https://img.php.cn/upload/article/202103/19/2021031909102812621.jpg', 'php登录失败的处理方法：首先创建一个表负责记录用户登录的信息；然后从user_login_info表查询最近30分钟内有没有相关密码错误的记录；接着统计记录总条数是否达到设定的错误次数；最后设置登录密码错误次数限制即可。\r\n\r\n\r\n\r\n本文操作环境：windows7系统、PHP7.1版，DELL G3电脑\r\n\r\nPHP实现登录失败次数限制\r\n\r\n登录密码错误次数限制\r\n\r\n安全对每个网站的重要性，不言自明。 其中，登陆又是网站中比较容易受到攻击的一个地方，那么我们如何对登陆功能的安全性加强呢？\r\n\r\n我们先来看一些知名的网站是如何做的\r\n\r\nGithub\r\n\r\nGithub网站同一个账号在同一个IP地址连续密码输错一定次数后，这个账号是会被锁定30分钟的。\r\n\r\nGithub这么做的主要原因，我觉得主要基于以下考虑：\r\n\r\n防止用户的账号密码被暴力破解\r\n\r\n实现思路\r\n\r\n既然这么多网站的登陆功能都这么个功能，那么具体如何实现的。下面，就具体说说。\r\n\r\n思路\r\n\r\n需要一个表(user_login_info)负责记录用户登录的信息，不管登录成功还是失败都记录。并且登陆失败还是成功需要能够区分开来。\r\n\r\n每次登陆时，都先从user_login_info表查询最近30分钟内(这里假设密码错误次数达到5次后，禁用用户30分钟)有没有相关密码错误的记录，然后统计一下记录总条数是否达到设定的错误次数。\r\n\r\n如果在相同IP下，同一个用户，在30分钟内密码错误次数达到设定的错误次数，就不让用户登录了。\r\n\r\n【推荐：PHP视频教程】\r\n\r\n具体代码与及表设计\r\n\r\n表设计\r\n\r\nuser_login_info表', '2021-01-01', 'PHP');
INSERT INTO `article` VALUES ('php如何去掉字符串末尾字符', 'https://img.php.cn/upload/article/000/000/024/6053250623ecf930.jpg', 'php去掉字符串末尾字符的方法：1、直接使用substr()函数倒序裁掉最后一位字符，语法“substr(string,0,-1)”；2、使用rtrim()函数，语法“rtrim(string,charlist)”。\r\n\r\n\r\n\r\n本教程操作环境：windows7系统、PHP7.1版，DELL G3电脑\r\n\r\nphp去掉字符串末尾字符\r\n\r\n方法1：使用substr()函数\r\n\r\n直接使用substr()函数倒序裁掉最后一位字符\r\n\r\n1\r\n\r\n2\r\n\r\n3\r\n\r\n4\r\n\r\n5\r\n\r\n6\r\n\r\n\r\nheader(\'content-type:text/html;charset=utf-8\');\r\n\r\n$str = \'123,234,345,\';\r\n\r\necho \"原字符串：\",$str,\'\r\n\';\r\n\r\necho \"去掉末尾字符的字符串：\",substr($str,0,-1);\r\n\r\n?>\r\n\r\n输出：\r\n\r\n1\r\n\r\n2\r\n\r\n原字符串：123,234,345,\r\n\r\n去掉末尾字符的字符串：123,234,345\r\n\r\n说明：\r\n\r\nsubstr() 函数返回字符串的一部分。语法：\r\n\r\n1\r\n\r\nsubstr(string,start,length)\r\n\r\n\r\n\r\n方法2：使用rtrim()函数\r\n\r\nrtrim() 函数移除字符串右侧的空白字符或其他预定义字符。\r\n\r\n1、指定末尾字符\r\n\r\n1\r\n\r\n2\r\n\r\n3\r\n\r\n4\r\n\r\n5\r\n\r\n6\r\n\r\n\r\nheader(\'content-type:text/html;charset=utf-8\');\r\n\r\n$str = \'123,234,345,\';\r\n\r\necho \"原字符串：\",$str,\'\r\n\';\r\n\r\necho \"去掉末尾字符的字符串：\",rtrim($str,\',\');\r\n\r\n?>\r\n\r\n输出：\r\n\r\n1\r\n\r\n2\r\n\r\n原字符串：123,234,345,\r\n\r\n去掉末尾字符的字符串：123,234,345\r\n\r\n2、不知道末尾字符\r\n\r\n1\r\n\r\n2\r\n\r\n3\r\n\r\n4\r\n\r\n5\r\n\r\n6\r\n\r\n7\r\n\r\n8\r\n\r\n9\r\n\r\n\r\nheader(\'content-type:text/html;charset=utf-8\');\r\n\r\n$str = \'123,234,345,1\';\r\n\r\necho \"原字符串：\",$str,\'\r\n\';\r\n\r\n \r\n\r\n//不知道末尾字符，需先获取末字符\r\n\r\n$last_char=$str{strlen($str)-1};\r\n\r\necho \"去掉末尾字符的字符串：\",rtrim($str,$last_char);\r\n\r\n?>\r\n\r\n输出：\r\n\r\n1\r\n\r\n2\r\n\r\n原字符串：123,234,345,1\r\n\r\n去掉末尾字符的字符串：123,234,345,\r\n\r\n推荐学习：《PHP视频教程》\r\n\r\n以上就是php如何去掉字符串末尾字符的详细内容，更多请关注php中文网其它相关文章！', '2021-01-01', 'PHP');
INSERT INTO `article` VALUES ('php异常和错误的区别是什么', 'https://img.php.cn/upload/article/202103/18/2021031817511956954.jpg', 'php异常和错误的区别：1、PHP错误是属于php程序自身的问题，一般是由非法的语法，环境问题导致的；2、PHP异常一般是业务逻辑上出现的不合预期、与正常流程不同的状况，不是语法错误。\r\n\r\n\r\n\r\n本教程操作环境：windows7系统、PHP5.6版，DELL G3电脑。\r\n\r\nphp异常和错误的区别：\r\n\r\nPHP错误：是属于php程序自身的问题，一般是由非法的语法，环境问题导致的，使得编译器无法通过检查，甚至无法运行的情况。平时遇到的warming、notice都是错误，只是级别不同而已。\r\n\r\nPHP异常：一般是业务逻辑上出现的不合预期、与正常流程不同的状况，不是语法错误。\r\n\r\n1\r\n\r\n2\r\n\r\n3\r\n\r\n4\r\n\r\n5\r\n\r\n6\r\n\r\n7\r\n\r\n8\r\n\r\n9\r\n\r\n10\r\n\r\n11\r\n\r\n12\r\n\r\n13\r\n\r\n14\r\n\r\n15\r\n\r\n16\r\n\r\n17\r\n\r\n18\r\n\r\n19\r\n\r\n20\r\n\r\n21\r\n\r\n22\r\n\r\n// 以除数为0为例，看看PHP是如何处理的\r\n\r\n\r\n$a = 0;\r\n\r\ntry {\r\n\r\n    echo 4/$a;\r\n\r\n}\r\n\r\ncatch (Exception $e){\r\n\r\n    echo $e->getMessage();\r\n\r\n}\r\n\r\n//报错，PHP是无法自动捕获异常的，必须手动抛出\r\n\r\n  \r\n\r\n  \r\n\r\n$a = 0;\r\n\r\ntry {\r\n\r\n    if($a == 0){\r\n\r\n        throw new Exception(\'除数不能为0\', 1);\r\n\r\n    }\r\n\r\n    echo 4/$a;//不会执行\r\n\r\n}\r\n\r\ncatch (Exception $e){\r\n\r\n    echo $e->getMessage();\r\n\r\n}\r\n\r\nPHP中对于异常的机制使用，一般用于业务逻辑判断上面，当业务逻辑不正常时，进行特殊处理。\r\n\r\n下面看一下PHP错误处理机制。PHP提供了set_error_handler()函数进行错误处理。当错误发生时，set_error_handler会统一处理错误。\r\n\r\n相关视频推荐：PHP编程从入门到精通\r\n\r\n以上就是php异常和错误的区别是什么的详细内容，更多请关注php中文网其它相关文章！', '2021-01-01', 'PHP');
INSERT INTO `article` VALUES ('linux下如何查看php-fpm是否安装', 'https://img.php.cn/upload/article/000/000/024/60532042dd48f908.jpg', 'linux下查看php-fpm是否安装的方法：打开终端，执行“whereis php-fpm”或者“find / -name php-fpm”命令，如果成功输出php-fpm的安装位置，则表示有安装。\r\n\r\n\r\n\r\n本教程操作环境：centos7系统、PHP5.6版，DELL G3电脑\r\n\r\nlinux下查看php-fpm是否安装\r\n\r\n方法一、whereis php-fpm\r\n\r\n1\r\n\r\n2\r\n\r\n3\r\n\r\n4\r\n\r\n5\r\n\r\n6\r\n\r\n[me@VM_0_14_centos application]# whereis php-fpm\r\n\r\nphp-fpm:\r\n\r\n/usr/sbin/php-fpm\r\n\r\n/etc/php-fpm.conf\r\n\r\n/etc/php-fpm.d\r\n\r\n/usr/share/man/man8/php-fpm.8.gz\r\n\r\n方法二、find / -name php-fpm\r\n\r\n1\r\n\r\n2\r\n\r\n3\r\n\r\n4\r\n\r\n5\r\n\r\n6\r\n\r\n7\r\n\r\n[me@VM_0_14_centos application]# find / -name php-fpm\r\n\r\n/var/log/php-fpm\r\n\r\n/usr/sbin/php-fpm\r\n\r\n/etc/sysconfig/php-fpm\r\n\r\n/etc/logrotate.d/php-fpm\r\n\r\n/run/php-fpm\r\n\r\n[root@VM_0_14_centos application]#\r\n\r\n推荐学习：《PHP视频教程》\r\n\r\n以上就是linux下如何查看php-fpm是否安装的详细内容，更多请关注php中文网其它相关文章！', '2021-01-01', 'PHP');
INSERT INTO `article` VALUES ('php的数据库修改语句是什么', 'https://img.php.cn/upload/article/202103/18/2021031817353472746.jpg', 'php的数据库修改语句是UPDATE，用于更新数据库表中已存在的记录，语法为【UPDATE table_name SET column1=value, column2=value2,...WHERE some_column=some 】。\r\n\r\n\r\n\r\n本教程操作环境：windows7系统、PHP5.6版，DELL G3电脑。\r\n\r\nUPDATE 语句用于更新数据库表中已存在的记录。\r\n\r\n语法\r\n\r\n1\r\n\r\n2\r\n\r\n3\r\n\r\nUPDATE table_name\r\n\r\nSET column1=value, column2=value2,...\r\n\r\nWHERE some_column=some_value\r\n\r\n注释：请注意 UPDATE 语法中的 WHERE 子句。WHERE 子句规定了哪些记录需要更新。如果您想省去 WHERE 子句，所有的记录都会被更新！\r\n\r\n如需学习更多关于 SQL 的知识，请访问我们的 SQL 教程。\r\n\r\n为了让 PHP 执行上面的语句，我们必须使用 mysqli_query() 函数。该函数用于向 MySQL 连接发送查询或命令。\r\n\r\n实例\r\n\r\n在本教程的前面章节中，我们创建了一个名为 \"Persons\" 的表，如下所示：\r\n\r\n\r\n\r\n下面的例子更新 \"Persons\" 表的一些数据：\r\n\r\n1\r\n\r\n2\r\n\r\n3\r\n\r\n4\r\n\r\n5\r\n\r\n6\r\n\r\n7\r\n\r\n8\r\n\r\n9\r\n\r\n10\r\n\r\n11\r\n\r\n\r\n$con=mysqli_connect(\"localhost\",\"username\",\"password\",\"database\");\r\n\r\n// 检测连接\r\n\r\nif (mysqli_connect_errno())\r\n\r\n{\r\n\r\n    echo \"连接失败: \" . mysqli_connect_error();\r\n\r\n}\r\n\r\nmysqli_query($con,\"UPDATE Persons SET Age=36\r\n\r\nWHERE FirstName=\'Peter\' AND LastName=\'Griffin\'\");\r\n\r\nmysqli_close($con);\r\n\r\n?>\r\n\r\n在这次更新后，\"Persons\" 表如下所示：\r\n\r\n\r\n\r\n相关视频推荐：PHP编程从入门到精通\r\n\r\n以上就是php的数据库修改语句是什么的详细内容，更多请关注php中文网其它相关文章！', '2021-01-01', 'PHP');
INSERT INTO `article` VALUES ('php怎么设置状态码', 'https://img.php.cn/upload/article/000/000/024/60531da39e7a2975.jpg', '在php中，可以使用http_response_code()函数来设置状态码，该函数用于设置响应的HTTP状态码，语法格式“http_response_code (状态码) ”。\r\n\r\n\r\n\r\n本教程操作环境：windows7系统、PHP7.1版，DELL G3电脑\r\n\r\nphp设置状态码\r\n\r\nhttp_response_code()函数用于获取/设置响应的 HTTP 状态码\r\n\r\n语法：\r\n\r\n1\r\n\r\nhttp_response_code ($response_code)\r\n\r\n参数：\r\n\r\nresponse_code：可选的 response_code 会设置响应的状态码。\r\n\r\n返回值：\r\n\r\n如果提供了 response_code，将返回先前的状态码。 如果未提供 response_code，会返回当前的状态码。 在 Web 服务器环境里，这些状态码的默认值都是 200。\r\n\r\n如果在非 Web 服务器环境里调用（比如 CLI 应用里）， 不提供 response_code 就会返回 false 。 在非 Web 服务器环境里，提供 response_code 会返回 true （仅仅在先前没有设置过状态码的时候）。\r\n\r\n示例：\r\n\r\n1\r\n\r\n2\r\n\r\n3\r\n\r\n4\r\n\r\n5\r\n\r\n6\r\n\r\n\r\n// 获取当前状态码，并设置新的状态码\r\n\r\nvar_dump(http_response_code(404));\r\n\r\n//获取新的状态码\r\n\r\nvar_dump(http_response_code());\r\n\r\n?>\r\n\r\n以上例程会输出：\r\n\r\n1\r\n\r\n2\r\n\r\nint(200)\r\n\r\nint(404)\r\n\r\n推荐学习：《PHP视频教程》\r\n\r\n以上就是php怎么设置状态码的详细内容，更多请关注php中文网其它相关文章！', '2021-01-01', 'PHP');
INSERT INTO `article` VALUES ('excel怎么冻结选定区域', 'https://img.php.cn/upload/article/202103/18/2021031817270344979.jpg', 'excel冻结选定区域的方法：首先选定你想固定不变的位置；然后点击表格最上面的菜单栏“视图”那里，再点击“冻结窗格”下方的“冻结窗格”即可。\r\n\r\n\r\n\r\n本文操作环境：Windows7系统，Microsoft Office Excel2010版本，Dell G3电脑。\r\n\r\nexcel冻结选定区域的方法：\r\n\r\n1、首先选定你想固定不变的位置，先把光标点击在想固定不变的表格下方，例如我想把第一行的固定住，那就把光标定位在第二行的第一个格子“A2”那里\r\n\r\n\r\n\r\n2、第二点击表格最上面的菜单栏“视图”那里，再点击“冻结窗格”下方的“冻结窗格”，也可按字母键F冻结窗格；取消的时候就点击取消冻结窗格或者按F键\r\n\r\n\r\n\r\n3、这样当表格数据内容较多时，就能方便你更好的去查看\r\n\r\n\r\n\r\n相关学习推荐：excel基础教程\r\n\r\n以上就是excel怎么冻结选定区域的详细内容，更多请关注php中文网其它相关文章！\r\n\r\n', '2021-01-01', 'PHP');

-- ----------------------------
-- Table structure for class
-- ----------------------------
DROP TABLE IF EXISTS `class`;
CREATE TABLE `class` (
  `name` varchar(50) DEFAULT NULL COMMENT '分类名'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of class
-- ----------------------------
INSERT INTO `class` VALUES ('Layui');
INSERT INTO `class` VALUES ('PHP');
INSERT INTO `class` VALUES ('ThinkPHP');
INSERT INTO `class` VALUES ('前端');
INSERT INTO `class` VALUES ('小程序');
INSERT INTO `class` VALUES ('服务器');
INSERT INTO `class` VALUES ('首页');
